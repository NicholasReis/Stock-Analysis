

class Stock:
	#Creates a global dictionary
	yearlyData = dict()
	
	#Creates a global stock symbol variable
	stock_symbol = ""
	def __init__(self, stock_symbol, years):
		#Assigns the stock symbol to the variable
		self.stock_symbol = stock_symbol
		self.loadFromFile(years)
	
	#Function for loading the information into the stock from a file generated by the data grabber	
	def loadFromFile(self, years):
		for year in years:
			#Creates an array to store each line
			lines =[]
			#Opens the file (Will be <stock_symbol>.txt)
			with open(self.stock_symbol+str(year)+".txt", "r") as tempData:
				#Assigns the text of each line to the array (Does it need to be append?)
				tempLines = tempData.readlines()
				for line in tempLines:
					lines.append(line)
			#For each line in the lines array
			data = dict()
			for line in lines:
				self.yearlyData[str(year)] = dict()
				#Assigns new array to hold the key:value pair split on the semicolon
				values = str(line).split(">")
				#print(values) #For assessment
				#If the key is "year"
				if(values[1] == "{}\n"):
					data[str(values[0])] = ""
				else:
					#The string format looks like label>{'raw':#######, 'fmt':########, etc...}
					#So this grabs just the raw number rather than any of the formatted versions
					#Honestly I could probably process this in DataGrabber rather than here, but I will
					#Do that when I refactor the classes to go file-less
					#With that said, this starts at the first ":" and ends at the first ","
					begin = str(values[1]).index(':') +1
					end = values[1].index(',')
					#Takes the raw number and assigns it as an integer to be worked with as a number
					data[str(values[0])] = int(values[1][begin:end])
			#Adds all the collected data (in dictionary form) into the yearly dictionary
			#That way when you call yearlyData[<year>] you get all the financials from just that year
			self.yearlyData[str(year)] = data

	#Using the keys given by getYears they can be sent here to get the Annual Revenue for that year
	#This will likey become getData and accept a label as another argument, I'm not sure why I did it this way
	#Though I suspect it's because of the way the data was separated by DataGrabber, but if I output it in a nice
	#Way that shouldn't end up mattering too much.
	def getData(self, year, label):
		#Returns the annual revenue from the associated year
		return self.yearlyData[str(year)][label]

		#Information I will want to keep track of. Will delete when I start implementing the Analyzer Class
		#pe
		#annual_revenue
		#profit_margin #(Net income / Total Revenue)
		#shares_issued
		#current_assets
		#current_liabilities
		#cash_flow
		#capital_expenditures
		#price #price to free cash flow < 15%
